## 12. 다형성 

### 01 다형성
- 그리스어 `많은 Poly` 와 `형태 morph`의 합성어로 `많은 형태를 가질 수 있는 능력`
- 컴퓨터 과학에서는 하나의 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의
- 객체지향 프로그래밍에서의 다형성 (===그림 추가====)
    - 오버로딩 다형성 : `하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우`
        - 서로 다른 타입의 파라미터를 가짐
        - 유사한 작업을 수행하는 메서드의 이름을 통일할 수 있다
        - ex) plus_money, plus_bigdecimal, plus_long => plus

    - 강제 다형성 : `언어가 지원하는 자동 타입변환 또는 사용자가 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식`
        - ex) `+ 연산자` 숫자끼리 일땐 숫자, 문자가 포함되어 있으면 숫자는 강제로 문자로 변환
        - 오버로딩 다형성과 강제 다형성을 함께 사용하면 판단이 어려워진다. 
    
    - 매개변수 다형성 : `제네릭 프로그래밍과 관련이 높으며 변수나 메서드의 타입을 임시로 선언 후 사용시점에 구체적인 타입을 지정하는 방식`
        - C# 제네릭

    - 포함 다형성 : `메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력`
        - 서브타입 다형성이라고도 불림
        - 객체지향 프로그래밍에서 가장 널리 알려진 형태
        - 가장 일반적인 방법은 상속 (그래서 서브타입이라고..)
        - `상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층 구축`

- 이번 장에서는 다형성의 다양한 측면 중에서 포함 다형성에 관해 중점적으로 다룬다. 

### 02 상속의 양면성
- 객체지향 프로그램을 작성하기 위해서는 항상 데이터와 행동이라는 두 가지 관점을 함께 고려해야 한다. 
- 상속 역시 데이터관점, 행동관점의 상속이 있다. 
- 상속은 코드 재사용 목적이 아니며 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것
- 상속의 매커니즘을 이해하는데 필요한 몇가지 개념
    - 업캐스팅
    - 동적 메서드 탐색
    - 동적 바인딩
    - self 참조
    - super 참조

#### 상속을 사용한 강의 평가

##### Lecture 클래스 살펴보기
- 수강생들의 성적을 계산하는 예제
    - 출력 목표 `Pass:3 Fail:2, A:1 B:1 C:1 D:0 F:2`
    - `Pass:3 Fail:2` 형식의 통계를 출력하는 Lecture 클래스 이미 존재.
    - Lecture를 재사용해 원하는 출력 기능을 구현
    - Lecture구조
        - 인스턴스 변수 : title(과목명), scores(성적리스트), pass(이수 기준)
        - 메서드
            - average() 평균값 계산
            - getScores() 성적리스트 반환
            - evaluate() "Pass:{0} Fail:{1} " 포멧으로 출력 결과 반환
            - passCount(), failCount()

##### 상속을 이용해 Lecture 클래스 재사용하기
- Grade 클래스 
    - 인스턴스 변수 : name(등급), lower(최소성적), upper(최대성적)
    - 메서드 
        - getName() : 등급이름 반환
        - isName() : 이름 비교
        - inClude() : 성적 등급이 유효한지 판단
- Lecture를 상속해 새 클래스 구현 -> GradeLecture
    - 인스턴스 변수 : grades(등급 리스트) 
    - evaluate 메서드 재정의
        ```java
        public class GradeLecture extends Lecture {

            @Override
            public String evaluate() {
                return super.evaluate() + ", " + gradesStatistics();
            }

            private String gradesStatistics() {
                return grades.stream()
                        .map(grade -> format(grade))
                        .collect(joining(" "));
            }

            private String format(Grade grade) {
                return String.format("%s:%d", grade.getName(), gradeCount(grade));
            }

            private long gradeCount(Grade grade) {
                return getScores()
                            .stream()
                            .filter(grade::include)
                            .count();
            }
        }
        ```
    - GradeLecture와 Lecture에 구현된 두 evaluate 메서드의 시그니처가 동일하다.
        - 동일할 경우 자식클래스의 메서드가 우선순위가 더 높다. 
        - 부모클래스의 구현을 새로운 구현으로 대체하는 것을 `메서드 오버라이딩` 이라 한다. 
    - 부모 클래스에는 없던 새로운 메서드를 추가하는 것도 가능하다. 
         ```java
            public double average(String gradeName) {
                    return grades.stream()
                            .filter(each -> each.isName(gradeName))
                            .findFirst()
                            .map(this::gradeAverage)
                            .orElse(0d);
                }

            private double gradeAverage(Grade grade) {
                return getScores().stream()
                        .filter(grade::include)
                        .mapToInt(Integer::intValue)
                        .average()
                        .orElse(0);
            }
        ```
        - 이름은 동일 하지만 시그니처는 다른 메서드 : `메서드 오버로딩`
- 다시 한번 강조하지만 상속의 일차적인 목표는 `코드 재사용` 이 아니다

#### 데이터 관점의 상속
- 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있다. 
===그림 넣자===

#### 행동 관점의 상속
- 상속은 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미
    - 실제로 클래스의 코드를 합치거나 복사하는 작업이 수행되는 것은 아니다. 
    - 런타임에 자식클래스에 정의되어 있지 않을 경우 부모클래스를 탐색한다. 
- 객체의 경우 서로 다른 상태를 저장할 수 있도록 독립적인 메모리를 할당 받아야 한다.
- 하지만 메서드의 경우 동일한 클래스의 인스턴스 끼리 공유가 가능하기에 한번만 메모리 로드 후 포인터를 갖는게 경제적

- 자식 클래스에서 부모 클래스로의 메서드 탐색이 가능하기 때문에 마치 부모 클래스의 복사본을 가진 것처럼 보인다.
- 각 객체에 포함된 class 포인터와 클래스에 포함된 parent 포인터를 조합하면 모든 부모 클래스에 접근하는 것이 가능하다. 

===그림===
- 이해를 쉽도록 표현한 개념적인 그림. 구체적인 방법은 언어나 플랫폼에 따라 다르다. 


### 03 업캐스팅과 동적 바인딩

#### 같은 메시지, 다른 메서드
- 각 교수별로 강의에 대한 성적 통계 계산하는 기능 추가.
- Professor 클래스 추가 
    - 생성자에서 Lecture 클래스를 주입받음
    - compileStatistics()에서 Lecture.evaluate(), Lecture.average()를 사용
- 생성자에 Lecture 대신 자식 클래스인 GradeLecture 의 인스턴스를 전달해도 아무 문제 없다.
    - 업캐스팅: 부모 클래스의 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능
    - 동적 바인딩: 선언된 변수의 타입이 아니라 메세지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다. 객체지향 시스템이 적절한 메서드를 실행시점에 결정하기에 가능

#### 업캐스팅 
- 상속을 하게 되면 부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐지기 때문에 부모대신 자식 클래스의 인스턴스 사용 가능
- 컴파일러는 명시적인 타입 변환 없이도 대체할 수 있게 허용한다. 
- `다운캐스팅`:  부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서는 명시적인 타입 캐스팅이 필요함 
- Lecture의 모든 자식 클래스는 Professor와 협력할 수 있는 무한한 확장 가능성을 가지기에 이 설계는 유연하며 확장이 용이하다. 

#### 동적 바인딩
- 정적 바인딩, 초기 바인딩, 컴파일 타입 바인딩 : 컴파일 타임에 호출할 함수를 결정하는 방식(전통적인 언어들)
- 동적 바인딩, 지연 바인딩 : 런타임에 호출할 함수를 결정(객체지향 언어)


### 04 동적 메서드 탐색과 다형성 






    

        

