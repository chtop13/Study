## 05. 책임 할당하기

### 01 책임 주도 설계를 향해

데이터 중심 설계에서의 두 가지 원칙

> - 데이터 보다 행동을 먼저 결정하라.
> - 협력이라는 문맥 안에서 책임을 결정하라.

- 데이터보다 행동을 먼저 결정하라
  - 객체에게 중요한 것은 외부에 제공하는 행동
  - 행동이란 곧 객체의 책임을 의미.
  - 책임중심 설계
    - `이 객체가 수행해야 하는 책임은 무엇인가`
    - ` 이 책임을 수행하는 데 필요한 데이터는 무엇인가`


- 협력이라는 문액 안에서 책임을 결정하라.
  - 객체에게 할당된 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 것이다. 
  - 적합한 책임이란 메시지 수신자가 아니라 전송자에게 적합한 책임을 의미한다. 
    - 객체를 결정한 후 메시지를 선택하는 것이 아니라 메시지를 결정 후에 객체를 선택해야 한다. 
    - 메시지를 먼저 결정하면 송신자는 수신자에 대한 가정을 할 수 없어 깔끔하게 캡슐화가 이루어진다.


- 책임주도 설계 
  - 3장의 내용 다시 나열
    - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
    - 시스템 책임을 더 작은 책임으로 분할한다
    - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
    - 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
    - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다. 


### 02 책임 할당을 위한 GRASP 패턴

General Responsibility Assignment Software Pattern(일반적인 책임 할당을 위한 소프트웨어 패턴)

- 도메인 개념에서 출발하기
    - 책임을 할당할 때 가장먼저 고민해야 하는 유력한 후보는 도메인 개념이다. 
    - 중요한 것은 설계를 시작하는 것이지 도메인 개념들을 완벽하게 정리하는 것이 아니다.(빠르게 설계와 구현을 진행하라)
    - 올바른 도메인 모델이란 존재하지 않는다.

- 정보 전문가에게 책임을 할당하라
  - 첫 단계는 애플리케이션이 제공해야 하는 기능을 앱에 전달된 메시지로 간주 하고 이것을 책임질 첫번째 객체를 선택하는 것으로 설계를 시작
    - 메세지를 전송할 객체는 무엇을 원하는가?
    - 메시지를 수신할 적합한 객체는 누구인가?
  - 정보 전무가 패턴에 따르면 필요한 정보를 가장 많이 알고 있는 객체에게 책임을 할당해야 한다. 
    - 책임을 수행하는 객체가 정보를 알고 잇다고 해서 그정보를 저장하고 있을 필욘 없다. 
  - 스스로 처리할 수 없는 작업이 있다면 외부에 도움을 요청.
    - 이 요청이 외부로 전송해야 하는 새로운 메시지
  - 적용 
    - 이미지로 보여주자 

- 높은 응집도와 낮은 결합도
  - 설계는 트레이드오프 활동이라는 것을 기억
    - 올바른 책임 할당을 위해 Information Expert 패턴 이외의 다른 책임 할당 패턴들을 함께 고려. 
  - Screening이 직접 DiscountCondition과 협력한다면?
    - 기능적으로는 동일. 
    - LOW COUPLING(낮은 결합도) 관점에서 본다면?
      - Movie에 이미 DiscountCondition 목록 속성을 가지고 있어서 이미 결합되어 있음
      - Movie와 DiscountCondition가 협력하면 추가 결합이 없기 때문에 더 좋은 선택
    - HiGH COHESION(높은 응집도) 관점에서 본다면?
      - Screening의 책임은 예매인데 DiscountCondition과 협력하면 요금계산에 관련된 책임 일부를 맡게됨
      - Movie가 할인여부를 필요로 한다는 사실 역시 알고 있어야 함.
      - 요금 계산 방식이 변경될 경우 Screening 도 변경이 됨


- 창조자에게 객체 생성 책임을 할당하라. 
  > GRASP의 CREATOR(창조자 패턴)
  >- 객체 A를 생성할 때 아래 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라. 
  >    - B가 A객체를 포함하거나 참조한다.
  >    - B가 A객체를 기록한다.
  >    - B가 A객체를 긴밀하게 사용한다.
  >    - B가 A객체를 초기화 하는데 필요한 데이터를 가지고 있다.(이 경우 B는 A에 대한 정보 전문가)
  >  - 이미 결합돼 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다. 

  - Reservation을 잘 알고 있거나, 긴밀하게 사용하거나, 초기화에 필요한 데이터를 가지고 있는 객체는?
    - Screening을 CREATOR로 선택하는 것이 적절해 보인다.

### 03 구현을 통한 검증 
- Screening 구현
  - `예매하라` 메시지의 응답 메서드 -> Reserve -> Reservation 창조
  - 책임을 수행하는데 필요한 인스턴스 변수
    - 상영시간 
    - 순번  
    - 영화(Movie) > 가격을 계산하라는 메세지 전송
  - `가격을 계산하라` 메시지를 전송할 CalculateFee 메서드
  - Movie.CalculateMovieFee 를 선언
    - <U>Movie 내부구현을 고려치 않고 Screening의 의도로 메시지를 결정 -> Movie의 캡슐화</U>
- Movie 구현
  - CalculateMovieFee 를 구현
    - IsDiscountable, CalculateDiscountAmount을 통해 할인여부 판단 및 요금계산
  - 인스턴스 변수
    - 영화 정보
    - 할인금액(DiscountAmount)
    - 할인비율(DiscountPercent)
    - 영화종류(MovieType)
  - IsDiscountable 구현
    - <U> `할인여부를 판단하라` 메시지를 처리할 DiscountCondition.IsSatisfiedBy 를 구현 </U>
    - DiscountConditions를 순회하며 DiscountCondition.IsSatisfiedBy를 통해 할인여부 판단 
  - CalculateDiscountAmount 구현
    - MovieType에 따라 적절한 할인 메소드를 호출
- DiscountCondition 구현
  - 인스턴스변수
    - 요일(dayOfWeek)
    - 시작시간(StartTime)
    - 종료시간(endTime)
    - 상영순번(Sequence)
  - IsSatisfiedBy 구현
    - type값에 따라 적절한 메소드를 호출

- DiscountCondition개선하기
    - 가장 큰 문제는 변경에 취약한 클래스를 포함하고 있다는 것
    - 세가지 이유로 변경될 수 있다
        - 새로운 할인 조건추가
        - 순번 조건을 판단하는 로직 변경
        - 기간 조건을 판단하는 로직 변경
    - 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮다. 
    - <u> 변경의 이유에 따라 클래스를 분리해야 한다</u>
    - 변경의 이유 파악하기
        - 인스턴스 변수가 초기화 되는 시점
            - 높은 응집도는 인스턴스를 생성할 때 모든 속성을 함께 초기화
            - 함께 초기화 되는 속성을 기준으로 코드를 분리 
        - 메서드들이 인스턴스 변수를 사용하는 방식
            - 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 응집도가 낮다
            - 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다. 


