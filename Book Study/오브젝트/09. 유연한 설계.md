## 09. 유연한 설계

- 앞장의 내용이 반복된다는 느낌을 받을 수 있다. 

### 01 개방-폐쇄 원칙
- 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다. 
  - 확장에 열려 있다 : 요구사항이 변경될 때 변경에 맞게 새로운 `동작`을 추가해서 기능을 확장할 수 이싿. 
  - 수정에 대해 닫혀 있다 : 기존의 `코드`를 수정하지 않고도 동작을 추가하거나 변경할 수 있다. 

#### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라.
- 영화 예매 시스템의 할인 정책을 의존성 관점에서 다시 살펴보자
  - 컴파일타임
    - Moive -> DiscountPolicy
  - 런타임
    - Moive -> AmountDiscountPolicy, PercentDiscountPolicy
- 할인 정책 설계는 이미 개방-폐쇄 원칙을 따르고 있다. 
  - 할인 정책을 추가해서 확장가능, 기존코드 수정 없음

#### 추상화가 핵심이다.
- 개방-폐쇠 원칙의 핵심은 `추상화에 의존하는 것`
- 개방-폐쇠 원칙 관점에서 생략되지 않고 남겨진 부분 : 공통점을 반영한 추상화의 결과물
    - 수정할 필요가 없어야 한다. 
    - 확장의 여지를 남긴다. 
- DiscountPolicy의 코드(코드에 오타?)
    - 할인 여부 판단해서 요금계산 : public Money calculateDiscountAmount
        - 변하지 않는 부분 
    - 할인된 요금 계산 : abstract protected Money getDiscountAmount
        - 변하는 부분 - 추상화로 생략된 부분
        - 생략된 부분을 구체화함으로써 할인 정책을 확장
- Movie의 코드
    - DiscountPolicy에 의존
        - DiscountPolicy는 변하지 않는 추상화
        - DiscountPolicy의 자식 클래스를 추가하더라도 영향이 없기에 수정에 대해 닫혀 있다. 
- 추상화를 했다고 모든 수정에 대해 닫혀있는 것은 아니다. 신중하게 결정하라.

### 02 생성 사용 분리
- 추상화를 했다고 내부에서 인스턴스를 생성해서는 안된다. 
    - 객체 생성에 대한 지식은 과도한 결합도를 초래하는 경향이 있다. 
- 문제는 객체 생성이 아니라 부적절한 곳에서 객체를 생성하는 것
- `생성과 사용을 분리`하면 유연하고 재사용 가능한 설계를 할 수 있다. 
    - 보편적인 방법 : 객체 생성 책임을 클라이언트로 옮기는 것
    - ex) Client가 DiscountPolicy 생성 후 Movie 에게 전달

#### FACTORY 추가하기 
- Client도 생성과 사용의 책임을 함께 지니고 있다. 
- 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가 = FACTORY
- Client는 사용과 관련된 책임만 진다. 

#### 순수한 가공물에게 책임 할당하기
- 정보 전문가 - 책임 할당의 기본 원칙
- FACTORY는 도메인이(정보가 없음) 아니다. 추가한 이유는 순수하게 기술적인 결정.
- 크레이그 라만의 시스템을 객체로 분해하는 2가지 방식
    - 표현적 분해 : 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다. 
        - 모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제점에 봉착
    - 행위적 분해 
        - 순수한 가공물 : 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체
        - 행동을 책임질 마땅한 도메인 개념이 존재하지 않는 다면 순수한 가공물을 추가하고 책임을 할당하라 
- 객체지향 애플리케이션의 대부분은 실제 도메인에서 발견할 수 없는 순순한 가공물로 가득 차 있다. 
- 도메인 추상화를 기반으로 애플리케이션 로직을 설계하는 동시에 품질의 측면에서 균형을 맞추는 데 필요한 객체들을 창조하라.   
    - 먼저 도메인의 본질적인 개념을 추상화를 이용해 구축하고 만족스럽지 못하다면 인공적인 객체를 창조 하라
    - 애플리케이션을 구축하는 것은 원하는 기능을 제공하기 위해서지 실세계 모방이 아니다. 

### 03 의존성 주입
- 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
- 세가지 방법
    1. 생성자 주입
        - 장점 : 객체가 올바른 상태로 생성되는 필요한 의존성 명확하게 표현
        - 단점 : 런타임에 변경 불가 
    2. Setter 주입
        - 장점 : 런타임에 의존성 변경 가능
        - 단점 : 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지 명시적 표현 불가 
    3. 메서드 주입
        - 생성자 주입에 비해 한 두개의 메서드에서만 의존성이 사용된다면 더 나은 방법일 수 있다.  

#### 숨겨진 의존성은 나쁘다 
- SERVICE LOCATOR 패턴 
    - 일종의 저장소, 인스턴스를 등록하고 반환할 수 있는 메서드를 구현한 저장소
    - 장점 : 사용하는 코드로 부터 구체 클래스가 무엇인지 인스턴스를 어떻게 얻을지 몰라도 되게 해준다.
    - 단점 : 의존성을 감춘다는 것
        - 의존성을 숨길 경우 관련 문제는 런타임에 발견된다. 
        - 단위 테스트 작성도 어렵다.
            - Service Locator는 정적 변수를 사용해 모든 단위 테스트 케이스에 걸쳐 상태를 공유
            - 각 단위 테스트는 고립돼야 한다는 기본 원칙 위반
        - 의존성을 이해하기 위해 코드 내부구현을 이해할 것을 강요 하게 된다
        - 의존성 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀러 떨어트려 코드를 이해하고 디버깅하기 어렵게 만든다. 
- 의존성 주입은 SERVICE LOCATOR 패턴의 단점들을 해결해 준다. (의존성 명시적 표현)
- 명시적인 의존성이 숨겨진 의존성보다 좋다!

### 04 의존성 역전 

#### 추상화와 의존성 역전
- 의존성 역전 원칙
	- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다. 
	- 추상화는 구체적인 상황에 의존해서는 안 된다. 구체적인 상황은 추상화에 의존해야 한다. 

#### 의존성 역전 원칙과 패키지
- 

